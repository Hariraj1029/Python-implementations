# Creating a Dictionary
d = {
    "name": "John",
    "age": 30,
    "city": "New York"
}
# Merging Dictionaries
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}

d.update({"name": "Hari", "age": 22, "city": "Visakha"}) # Updates the dictionary with the given key-value pairs
value = d.get("Hari") # Retrieves the value of the given key from the dictionary. If the key is not found, it returns None by default.
value = dict1.get("a", 0) # Retrieves the value for a given key, with a default value (0) if the key is not present.
removed_value = d.pop("name") # Removes the given key from the dictionary and returns the corresponding value.
removed_pair = d.popitem() # Removes the last inserted key-value pair from the dictionary and returns it as a tuple.
d.clear() # Clears the dictionary.
items = d.items() # Returns a list of tuples containing the key-value pairs of the dictionary.
keys = d.keys()# Returns a list of keys of the dictionary.
values = d.values() # Returns a list of values of the dictionary.
copy_of_d = d.copy() # Returns a copy of the dictionary.
value = d.setdefault("name", "Hari")  # If the key is present, it returns the corresponding value. If not, it inserts the key with the given default value and returns the default value.

# Creates a new dictionary with the given keys and default values.
keys = ['a', 'b', 'c']
default_value = 0
new_dict = dict.fromkeys(keys, default_value)

del d["age"] # Deletes the given key from the dictionary.
del d # Deletes the dictionary.

# Additional Dictionary Operations

merged_dict = {**dict1, **dict2}
# Merges two dictionaries into a new one.
# In case of key conflicts, the values from the second dictionary (dict2) take precedence.

# Dictionary Comprehension
squared_dict = {key: key**2 for key in range(5)}
# Creates a new dictionary with keys as numbers and values as their squares.

# Nested Dictionaries
nested_dict = {
    "person": {
        "name": "John",
        "age": 30
    },
    "location": {
        "city": "New York",
        "country": "USA"
    }
}
# You can have dictionaries within dictionaries to represent hierarchical data.

# Iterates through the keys in the dictionary.
for key in dict1:
    print(key, dict1[key])

# Iterates through key-value pairs in the dictionary.
for key, value in dict1.items():
    print(key, value)


# Checks if a key exists in the dictionary.
key_exists = "b" in dict1

# Returns the number of key-value pairs in the dictionary.
dict_length = len(dict1)

# Dictionary Comparison
dict3 = {"a": 1, "b": 2}
dict4 = {"b": 2, "a": 1}
are_equal = dict3 == dict4
# Compares dictionaries for equality (order doesn't matter).

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Creating a Dictionary with a Default Value Generator
from collections import defaultdict

def default_value():
    return 0

d = defaultdict(default_value)
# Creates a dictionary where missing keys have a default value generated by the 'default_value' function.

# Flattening a Nested Dictionary
nested_dict = {
    "person": {
        "name": "John",
        "age": 30
    },
    "location": {
        "city": "New York",
        "country": "USA"
    }
}

flattened_dict = {}
for key, value in nested_dict.items():
    if isinstance(value, dict):
        for sub_key, sub_value in value.items():
            flattened_key = key + "_" + sub_key
            flattened_dict[flattened_key] = sub_value
    else:
        flattened_dict[key] = value
# Flattens a nested dictionary into a flat dictionary.

# Using Dictionaries for Frequency Count
text = "This is a sample text for frequency counting."
frequency = {}
for char in text:
    if char.isalpha():
        char = char.lower()
        frequency[char] = frequency.get(char, 0) + 1
# Counts the frequency of each alphabet character in the text.

# Dictionary Filtering Using Comprehension
original_dict = {"a": 1, "b": 2, "c": 3, "d": 4}
filtered_dict = {key: value for key, value in original_dict.items() if value % 2 == 0}
# Creates a new dictionary with key-value pairs from the original dictionary that meet the filtering condition.

# Creating a Dictionary from Two Lists
keys = ["a", "b", "c"]
values = [1, 2, 3]
dict_from_lists = {key: value for key, value in zip(keys, values)}
# Creates a dictionary from two lists, using one list for keys and another for values.

# Inverting a Dictionary
original_dict = {"a": 1, "b": 2, "c": 3}
inverted_dict = {value: key for key, value in original_dict.items()}
# Inverts the original dictionary, making values keys and keys values.

# Dictionary of Sets
set_dict = {1: {1, 2, 3}, 2: {3, 4, 5}, 3: {1, 4, 6}}
# Uses dictionaries to store sets as values.

# Dictionary of Lists
list_dict = {"fruits": ["apple", "banana", "cherry"], "colors": ["red", "yellow", "purple"]}
# Uses dictionaries to store lists as values.

# Dictionary Comprehension with Conditionals
original_dict = {"a": 1, "b": 2, "c": 3, "d": 4}
conditional_dict = {key: value if value % 2 == 0 else 0 for key, value in original_dict.items()}
# Creates a new dictionary with values modified based on a conditional expression.

# Dictionary with Dictionary Comprehension
nested_dict = {key: {sub_key: sub_key * 2 for sub_key in range(3)} for key in range(3)}
# Creates a nested dictionary using dictionary comprehension.

# Merge Dictionaries (Python 3.9+)
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}
merged_dict = dict1 | dict2
# Merges two dictionaries into a new one.
# In case of key conflicts, the values from the second dictionary (dict2) take precedence.

